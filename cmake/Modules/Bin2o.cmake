#===============================================================================
#
# Binary file to object tool
#
# Script usage:
#   `cmake -P /path/to/Bin2o.cmake -- <output-file> [HEADER <header-file>] [ALIGNMENT <byte-alignment>] [PREFIX <symbol-prefix>] [SUFFIX_START <start-symbol-suffix>] [SUFFIX_END <end-symbol-suffix>] [SUFFIX_SIZE <size-symbol-suffix>] [NAME_WE] [ERROR_IGNORE] <input-files>...`
#
# CMake usage:
#   `bin2o(<output-file> [HEADER <header-file>] [ALIGNMENT <byte-alignment>] [PREFIX <symbol-prefix>] [SUFFIX_START <start-symbol-suffix>] [SUFFIX_END <end-symbol-suffix>] [SUFFIX_SIZE <size-symbol-suffix>] [NAME_WE] [ERROR_IGNORE] <input-files>...)`
#
# `HEADER` corresponding header file output name.
# `ALIGNMENT` byte alignment of each input (default 4).
# `PREFIX` prefix for all symbols.
# `SUFFIX_START` suffix for the start symbols.
# `SUFFIX_END` suffix for the end symbols (default "_end").
# `SUFFIX_SIZE` suffix for the size symbols (default "_len").
# `NAME_WE` remove longest extension from symbols.
# `ERROR_IGNORE` ignore missing files.
#
# Copyright (C) 2021-2024 gba-toolchain contributors
# For conditions of distribution and use, see copyright notice in LICENSE.md
#
#===============================================================================

function(bin2o output)
    set(options NAME_WE ERROR_IGNORE)
    set(oneValueArgs HEADER ALIGNMENT PREFIX SUFFIX_START SUFFIX_END SUFFIX_SIZE)
    cmake_parse_arguments(ARGS "${options}" "${oneValueArgs}" "" ${ARGN})

    if(NOT ARGS_UNPARSED_ARGUMENTS)
        message(FATAL_ERROR "Bin2o.cmake requires input files.")
    endif()

    if(NOT ARGS_ALIGNMENT)
        set(ARGS_ALIGNMENT 4)
    endif()
    if(NOT ARGS_SUFFIX_END)
        set(ARGS_SUFFIX_END "_end")
    endif()
    if(NOT ARGS_SUFFIX_SIZE)
        set(ARGS_SUFFIX_SIZE "_len")
    endif()

    if(ARGS_HEADER)
        string(APPEND headerContents [=[
/* Generated by Bin2o.cmake */
#pragma once

#if __cplusplus >= 201703L
#   include <cstddef>
#elif __cplusplus >= 201103L
#   include <cstddef>
#   include <cstdint>
#else
#   include <stddef.h>
#   include <stdint.h>
#endif

#if __cplusplus
extern "C" {
#endif
]=])
    endif()

    function(split_path result path)
        if(UNIX AND path MATCHES "^/")
            set(rootName "/")
        else()
            cmake_path(GET path ROOT_NAME rootName)
        endif()

        unset(components)

        while(1)
            cmake_path(GET path FILENAME name)
            if(name)
                cmake_path(GET path PARENT_PATH path)
                list(INSERT components 0 "${name}")
            else()
                break()
            endif()
        endwhile()

        if(rootName)
            list(INSERT components 0 "${rootName}")
        endif()

        set(${result} ${components} PARENT_SCOPE)
    endfunction()

    get_filename_component(cwd "." ABSOLUTE)
    split_path(cwdComponents "${cwd}")
    list(LENGTH cwdComponents cwdComponentsLength)

    function(__bin2o_get_symbol_name resultSymbol inputPath)
        split_path(inputComponents "${inputPath}")

        list(LENGTH inputComponents inputComponentsLength)
        if(${cwdComponentsLength} VERSION_LESS ${inputComponentsLength})
            set(minLength ${cwdComponentsLength})
        else()
            set(minLength ${inputComponentsLength})
        endif()
        math(EXPR minLength "${minLength} - 1")

        unset(symbolName)
        foreach(i RANGE ${minLength})
            list(GET cwdComponents ${i} component1)
            list(GET inputComponents ${i} component2)
            if(NOT "${component1}" STREQUAL "${component2}")
                break()
            endif()
            list(APPEND symbolName ${component1})
        endforeach()
        list(LENGTH symbolName symbolNameLength)
        list(SUBLIST inputComponents ${symbolNameLength} -1 symbolComponents)

        string(REGEX REPLACE "[^a-zA-Z0-9_;]" "_" symbol "${symbolComponents}")
        if("${symbol}" MATCHES "^[0-9]")
            set(${resultSymbol} "_${symbol}" PARENT_SCOPE)
        else()
            set(${resultSymbol} "${symbol}" PARENT_SCOPE)
        endif()
    endfunction()

    list(REMOVE_DUPLICATES ARGS_UNPARSED_ARGUMENTS)
    foreach(input ${ARGS_UNPARSED_ARGUMENTS})
        if(ARGS_ERROR_IGNORE AND NOT EXISTS "${input}")
            continue()
        endif()

        if(NOT EXISTS "${input}")
            if(NOT IS_ABSOLUTE "${input}" AND EXISTS "${CMAKE_CURRENT_SOURCE_DIR}/${input}")
                set(input "${CMAKE_CURRENT_SOURCE_DIR}/${input}")
            else()
                message(FATAL_ERROR "Cannot find ${input}")
            endif()
        endif()

        string(REGEX REPLACE "[^a-zA-Z0-9_;]" "_" inputSymbolName "${input}")
        if(ARGS_NAME_WE)
            get_filename_component(inputWe "${input}" NAME_WE)
            __bin2o_get_symbol_name(symbolName "${inputWe}")
        else()
            get_filename_component(inputName "${input}" NAME)
            __bin2o_get_symbol_name(symbolName "${inputName}")
        endif()

        list(APPEND inputs "${input}")

        list(APPEND objcopyRenames
                "_binary_${inputSymbolName}_start=${ARGS_PREFIX}${symbolName}${ARGS_SUFFIX_START}"
                "_binary_${inputSymbolName}_end=${ARGS_PREFIX}${symbolName}${ARGS_SUFFIX_END}"
                "_binary_${inputSymbolName}_size=${ARGS_PREFIX}${symbolName}${ARGS_SUFFIX_SIZE}"
        )

        if(ARGS_HEADER)
            file(SIZE "${input}" inputSize)

            string(APPEND headerContents "\n/* ${input} */\n")
            string(APPEND headerContents "#if __cplusplus >= 201703L\n")
            string(APPEND headerContents "inline constexpr std::size_t ${ARGS_PREFIX}${symbolName}${ARGS_SUFFIX_SIZE} = ${inputSize};\n")
            string(APPEND headerContents "extern const std::byte ${ARGS_PREFIX}${symbolName}${ARGS_SUFFIX_START}[];\n")
            string(APPEND headerContents "extern const std::byte ${ARGS_PREFIX}${symbolName}${ARGS_SUFFIX_END}[];\n")
            string(APPEND headerContents "#elif __cplusplus >= 201103L\n")
            string(APPEND headerContents "inline constexpr std::size_t ${ARGS_PREFIX}${symbolName}${ARGS_SUFFIX_SIZE} = ${inputSize};\n")
            string(APPEND headerContents "extern const std::uint8_t ${ARGS_PREFIX}${symbolName}${ARGS_SUFFIX_START}[];\n")
            string(APPEND headerContents "extern const std::uint8_t ${ARGS_PREFIX}${symbolName}${ARGS_SUFFIX_END}[];\n")
            string(APPEND headerContents "#else\n")
            string(APPEND headerContents "#\tdefine ${ARGS_PREFIX}${symbolName}${ARGS_SUFFIX_SIZE} ((size_t) ${inputSize})\n")
            string(APPEND headerContents "extern const uint8_t ${ARGS_PREFIX}${symbolName}${ARGS_SUFFIX_START}[];\n")
            string(APPEND headerContents "extern const uint8_t ${ARGS_PREFIX}${symbolName}${ARGS_SUFFIX_END}[];\n")
            string(APPEND headerContents "#endif\n\n")
        endif()
    endforeach()


    if(ARGS_HEADER)
        string(APPEND headerContents [=[
#if __cplusplus
} /* extern "C" */
#endif
]=])
    endif()

    if(CMAKE_GENERATOR MATCHES "Ninja")
        get_filename_component(name "${output}" NAME_WE)
        set(byproduct "${name}.s")
        file(WRITE "${byproduct}" "@ Automatically generated. Do not edit!

.syntax unified
.cpu arm7tdmi
.arch armv4t
")

        function(split var size)
            string(LENGTH ${${var}} len)

            set(chunks)
            foreach(ii RANGE 0 ${len} ${size})
                string(SUBSTRING ${${var}} ${ii} ${size} chunk)
                list(APPEND chunks ${chunk})
            endforeach ()

            set(${var} ${chunks} PARENT_SCOPE)
        endfunction()

        foreach(input ${inputs})
            file(READ "${input}" data HEX)
            string(LENGTH ${data} size)
            split(data 32)

            string(REGEX REPLACE "[^a-zA-Z0-9_;]" "_" inputSymbolName "${input}")
            if(ARGS_NAME_WE)
                get_filename_component(inputWe "${input}" NAME_WE)
                __bin2o_get_symbol_name(symbolName "${inputWe}")
            else()
                get_filename_component(inputName "${input}" NAME)
                __bin2o_get_symbol_name(symbolName "${inputName}")
            endif()

            file(APPEND "${byproduct}" "
    .section .rodata.${symbolName}, \"a\", %progbits
    .balign
    .global ${ARGS_PREFIX}${symbolName}${ARGS_SUFFIX_START}
${ARGS_PREFIX}${symbolName}${ARGS_SUFFIX_START}:
    ")

            foreach(line ${data})
                split(line 2)
                list(TRANSFORM line PREPEND "0x")
                list(JOIN line ", " line)

                file(APPEND "${byproduct}" ".byte ${line}
    ")
            endforeach()

            math(EXPR size "${size} / 2")

            file(APPEND "${byproduct}" "
    .global ${ARGS_PREFIX}${symbolName}${ARGS_SUFFIX_END}
${ARGS_PREFIX}${symbolName}${ARGS_SUFFIX_END}:

    .global ${ARGS_PREFIX}${symbolName}${ARGS_SUFFIX_SIZE}
    .balign 4
${ARGS_PREFIX}${symbolName}${ARGS_SUFFIX_SIZE}: .int ${size}
    ")
        endforeach()

        if(CMAKE_C_COMPILER)
            set(compiler "${CMAKE_C_COMPILER}")
        elseif(CMAKE_CXX_COMPILER)
            set(compiler "${CMAKE_CXX_COMPILER}")
        else()
            message(FATAL_ERROR "Bin2o with Ninja requires either a C or C++ compiler")
        endif()

        execute_process(COMMAND "${compiler}" -mcpu=arm7tdmi -march=armv4t -c "${byproduct}" -o "${output}")
        file(REMOVE "${byproduct}")
        execute_process(COMMAND "${CMAKE_OBJCOPY}" --set-section-alignment .rodata=${ARGS_ALIGNMENT} "${output}")
    else()
        execute_process(COMMAND "${CMAKE_LINKER}" -r -b binary -o "${output}" ${inputs})

        foreach(rename ${objcopyRenames})
            execute_process(COMMAND "${CMAKE_OBJCOPY}" --redefine-sym ${rename} "${output}")
        endforeach()

        execute_process(COMMAND "${CMAKE_OBJCOPY}" --set-section-alignment .data=${ARGS_ALIGNMENT} "${output}")
        execute_process(COMMAND "${CMAKE_OBJCOPY}" --rename-section .data=.rodata,alloc,load,readonly,data,contents "${output}")
    endif()

    if(ARGS_HEADER)
        file(WRITE "${ARGS_HEADER}" "${headerContents}")
    endif()
endfunction()

if(CMAKE_SCRIPT_MODE_FILE STREQUAL CMAKE_CURRENT_LIST_FILE)
    # Collect arguments past -- into SCRIPT_ARGN
    foreach(ii RANGE ${CMAKE_ARGC})
        if(${ii} EQUAL ${CMAKE_ARGC})
            break()
        elseif("${CMAKE_ARGV${ii}}" STREQUAL --)
            set(start ${ii})
        elseif(DEFINED start)
            list(APPEND SCRIPT_ARGN "${CMAKE_ARGV${ii}}")
        endif()
    endforeach()
    unset(start)
    unset(CMAKE_SCRIPT_MODE_FILE) # Enable nested include()

    # Forward script args to function
    bin2o(${SCRIPT_ARGN})
else()
    set(BIN2O_PATH "${CMAKE_CURRENT_LIST_FILE}")
    if(CMAKE_GENERATOR MATCHES "Ninja")
        # Ninja puts binary .o files in front of the linker, which causes ABI mismatch problems
        if(CMAKE_C_COMPILER OR CMAKE_CXX_COMPILER)
            set(BIN2O_COMMAND "${CMAKE_COMMAND}" -D CMAKE_GENERATOR=Ninja -D CMAKE_C_COMPILER=\"${CMAKE_C_COMPILER}\" -D CMAKE_CXX_COMPILER=\"${CMAKE_CXX_COMPILER}\" -P "${CMAKE_CURRENT_LIST_FILE}" --)
        else()
            message(FATAL_ERROR "Bin2o with Ninja requires either a C or C++ compiler")
        endif()
    else()
        set(BIN2O_COMMAND "${CMAKE_COMMAND}" -D CMAKE_LINKER=\"${CMAKE_LINKER}\" -D CMAKE_OBJCOPY=\"${CMAKE_OBJCOPY}\" -P "${CMAKE_CURRENT_LIST_FILE}" --)
    endif()
endif()
